package com.honeyai.service;

import com.honeyai.config.EtiquetteConfig;
import com.honeyai.config.LabelPreset;
import com.honeyai.dto.EtiquetteData;
import com.honeyai.exception.PdfGenerationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.font.PDFont;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.font.Standard14Fonts;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Path;

/**
 * Service for PDF document generation using Apache PDFBox.
 * Foundation service for label generation feature.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PdfService {

    private final EtiquetteConfig etiquetteConfig;

    /**
     * Creates a new empty PDF document.
     * Caller is responsible for closing the document.
     *
     * @return new PDDocument instance
     */
    public PDDocument createDocument() {
        return new PDDocument();
    }

    /**
     * Creates a new page with the specified size.
     *
     * @param pageSize the page dimensions (e.g., PDRectangle.A4)
     * @return new PDPage with specified size
     */
    public PDPage createPage(PDRectangle pageSize) {
        return new PDPage(pageSize);
    }

    /**
     * Creates a new A4-sized page.
     *
     * @return new PDPage with A4 dimensions (595 x 842 points)
     */
    public PDPage createA4Page() {
        return createPage(PDRectangle.A4);
    }

    /**
     * Adds text to a page at the specified coordinates.
     * Coordinates origin is bottom-left corner of the page.
     *
     * @param document the PDF document
     * @param page     the page to add text to
     * @param text     the text to write
     * @param x        x coordinate in points (from left)
     * @param y        y coordinate in points (from bottom)
     * @param fontSize font size in points
     */
    public void addTextToPage(PDDocument document, PDPage page, String text, float x, float y, float fontSize) {
        try (PDPageContentStream contentStream = new PDPageContentStream(
                document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {

            PDType1Font font = new PDType1Font(Standard14Fonts.FontName.HELVETICA);

            contentStream.beginText();
            contentStream.setFont(font, fontSize);
            contentStream.newLineAtOffset(x, y);
            contentStream.showText(text);
            contentStream.endText();

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to add text to page: " + e.getMessage(), e);
        }
    }

    /**
     * Adds text to a page with bold font.
     *
     * @param document the PDF document
     * @param page     the page to add text to
     * @param text     the text to write
     * @param x        x coordinate in points
     * @param y        y coordinate in points
     * @param fontSize font size in points
     */
    public void addBoldTextToPage(PDDocument document, PDPage page, String text, float x, float y, float fontSize) {
        try (PDPageContentStream contentStream = new PDPageContentStream(
                document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {

            PDType1Font font = new PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD);

            contentStream.beginText();
            contentStream.setFont(font, fontSize);
            contentStream.newLineAtOffset(x, y);
            contentStream.showText(text);
            contentStream.endText();

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to add bold text to page: " + e.getMessage(), e);
        }
    }

    /**
     * Generates a test PDF with sample text.
     * Used to verify PDFBox setup is working correctly.
     *
     * @param outputPath path where the PDF will be saved
     */
    public void generateTestPdf(Path outputPath) {
        log.info("Starting test PDF generation to: {}", outputPath);

        try (PDDocument document = createDocument()) {
            PDPage page = createA4Page();
            document.addPage(page);

            // Add test text
            addTextToPage(document, page, "HoneyAI Test PDF", 50, 750, 24);
            addTextToPage(document, page, "This is a test document generated by PdfService.", 50, 700, 12);
            addTextToPage(document, page, "Apache PDFBox 3.0.1 is working correctly.", 50, 680, 12);

            document.save(outputPath.toFile());
            log.info("Test PDF generation completed successfully: {}", outputPath);

        } catch (IOException e) {
            log.error("Failed to generate test PDF: {}", e.getMessage(), e);
            throw new PdfGenerationException("Failed to generate test PDF: " + e.getMessage(), e);
        }
    }

    /**
     * Generates a test PDF with default output path ./test-output.pdf
     */
    public void generateTestPdf() {
        generateTestPdf(Path.of("./test-output.pdf"));
    }

    /**
     * Converts millimeters to PDF points.
     * 1 point = 1/72 inch, 1 inch = 25.4 mm
     * Therefore: 1 mm = 72/25.4 = 2.83465 points
     *
     * @param mm value in millimeters
     * @return value in points
     */
    public float mmToPoints(float mm) {
        return mm * 2.83465f;
    }

    /**
     * Converts points to millimeters.
     *
     * @param points value in points
     * @return value in millimeters
     */
    public float pointsToMm(float points) {
        return points / 2.83465f;
    }

    /**
     * Gets the etiquette configuration.
     *
     * @return the EtiquetteConfig with exploitation details and label settings
     */
    public EtiquetteConfig getEtiquetteConfig() {
        return etiquetteConfig;
    }

    // ==================== Label Rendering ====================

    /** Padding inside label border in mm (at reference scale) */
    private static final float PADDING_MM = 1.5f;

    /** Line spacing in mm (at reference scale) */
    private static final float LINE_SPACING_MM = 0.8f;

    /** Extra margin for sections in mm (at reference scale) */
    private static final float SECTION_MARGIN_MM = 1.2f;

    /** Border line width in points */
    private static final float BORDER_WIDTH_PT = 0.5f;

    /** Reference label height in mm (font sizes are calibrated for this) */
    private static final float REFERENCE_HEIGHT_MM = 40.0f;

    /** Font size for header line (at reference scale) */
    private static final float FONT_SIZE_HEADER = 5.5f;

    /** Font size for exploitation name (bold, at reference scale) */
    private static final float FONT_SIZE_NAME = 6.5f;

    /** Font size for address/contact info (at reference scale) */
    private static final float FONT_SIZE_INFO = 5.5f;

    /** Font size for weight (bold, at reference scale) */
    private static final float FONT_SIZE_WEIGHT = 7.0f;

    /** Font size for price (bold, larger, at reference scale) */
    private static final float FONT_SIZE_PRICE = 8.0f;

    /**
     * Renders a single honey label at the specified position on the page.
     * Layout:
     * 1. "Récolté en FRANCE et mis en pot par l'apiculteur" (FRANCE in bold)
     * 2. Exploitation name (bold, with margins)
     * 3-4. Address (2 lines)
     * 5. Phone
     * 6. SIRET
     * 7. DLUO
     * 8. Weight in grams (bold, with space above)
     * 9. Price (bold, larger font)
     * All text centered.
     *
     * @param document  the PDF document
     * @param page      the page to render on
     * @param data      the label data containing all fields
     * @param x         x coordinate in points (from left, bottom-left of label)
     * @param y         y coordinate in points (from bottom, bottom-left of label)
     * @param widthMm   label width in millimeters
     * @param heightMm  label height in millimeters
     */
    public void renderLabel(PDDocument document, PDPage page, EtiquetteData data,
                            float x, float y, float widthMm, float heightMm) {
        float widthPt = mmToPoints(widthMm);
        float heightPt = mmToPoints(heightMm);

        // Scale factor: fonts/spacings are calibrated for REFERENCE_HEIGHT_MM
        float scale = heightMm / REFERENCE_HEIGHT_MM;

        float paddingPt = mmToPoints(PADDING_MM * scale);
        float lineSpacingPt = mmToPoints(LINE_SPACING_MM * scale);
        float sectionMarginPt = mmToPoints(SECTION_MARGIN_MM * scale);

        float fontHeader = FONT_SIZE_HEADER * scale;
        float fontInfo = FONT_SIZE_INFO * scale;
        float fontWeight = FONT_SIZE_WEIGHT * scale;
        float fontPrice = FONT_SIZE_PRICE * scale;

        try (PDPageContentStream cs = new PDPageContentStream(
                document, page, PDPageContentStream.AppendMode.APPEND, true, true)) {

            // 1. Draw border rectangle
            drawBorder(cs, x, y, widthPt, heightPt);

            // Calculate content area
            float contentX = x + paddingPt;
            float contentWidth = widthPt - (2 * paddingPt);
            float currentY = y + heightPt - paddingPt;

            PDFont fontBold = new PDType1Font(Standard14Fonts.FontName.HELVETICA_BOLD);
            PDFont fontRegular = new PDType1Font(Standard14Fonts.FontName.HELVETICA);

            // Line 1: "Récolté en FRANCE et mis en pot par l'apiculteur" (FRANCE in bold)
            currentY = drawMixedTextCentered(cs, "Recolté en ", "FRANCE", " et mis en pot par l'apiculteur",
                    fontRegular, fontBold, fontHeader, contentX, currentY, contentWidth);
            currentY -= sectionMarginPt;

            // Line 2: Exploitation name (bold, with margins)
            if (data.getNomApiculteur() != null && !data.getNomApiculteur().isBlank()) {
                currentY = drawCenteredText(cs, data.getNomApiculteur(), fontBold, fontHeader,
                        contentX, currentY, contentWidth);
            }
            currentY -= sectionMarginPt;

            // Lines 3-4: Address (split into 2 lines if needed)
            if (data.getAdresse() != null && !data.getAdresse().isBlank()) {
                String[] addressLines = splitAddress(data.getAdresse());
                for (String line : addressLines) {
                    if (!line.isBlank()) {
                        currentY = drawCenteredText(cs, line, fontRegular, fontInfo,
                                contentX, currentY, contentWidth);
                        currentY -= lineSpacingPt;
                    }
                }
            }

            // Line 5: Phone
            if (data.getTelephone() != null && !data.getTelephone().isBlank()) {
                currentY = drawCenteredText(cs, data.getTelephone(), fontRegular, fontInfo,
                        contentX, currentY, contentWidth);
                currentY -= lineSpacingPt;
            }

            // Line 6: SIRET
            if (data.getSiret() != null && !data.getSiret().isBlank()) {
                currentY = drawCenteredText(cs, "SIRET: " + data.getSiret(), fontRegular, fontInfo,
                        contentX, currentY, contentWidth);
                currentY -= lineSpacingPt;
            }

            // Line 7: DLUO
            String dluoLine = "A consommer de preference avant fin: " + data.getDluoFormatted();
            currentY = drawCenteredText(cs, dluoLine, fontRegular, fontInfo,
                    contentX, currentY, contentWidth);
            currentY -= sectionMarginPt;

            // Line 8: Weight in grams (bold, with space above)
            String weightLine = getWeightInGrams(data.getFormatPot());
            currentY = drawCenteredText(cs, weightLine, fontBold, fontWeight,
                    contentX, currentY, contentWidth);
            currentY -= lineSpacingPt;

            // Line 9: Price (bold, larger font)
            if (data.getPrixUnitaire() != null) {
                String priceLine = formatPrice(data.getPrixUnitaire());
                drawCenteredText(cs, priceLine, fontBold, fontPrice,
                        contentX, currentY, contentWidth);
            }

            log.debug("Label rendered at ({}, {}) size {}x{}mm scale={}", x, y, widthMm, heightMm, scale);

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to render label: " + e.getMessage(), e);
        }
    }

    /**
     * Draws text with a bold word in the middle (for "FRANCE").
     */
    private float drawMixedTextCentered(PDPageContentStream cs, String before, String boldPart, String after,
                                        PDFont fontRegular, PDFont fontBold, float fontSize,
                                        float x, float y, float width) throws IOException {
        // Calculate total width
        float beforeWidth = fontRegular.getStringWidth(sanitizeText(before)) / 1000 * fontSize;
        float boldWidth = fontBold.getStringWidth(sanitizeText(boldPart)) / 1000 * fontSize;
        float afterWidth = fontRegular.getStringWidth(sanitizeText(after)) / 1000 * fontSize;
        float totalWidth = beforeWidth + boldWidth + afterWidth;

        float startX = x + (width - totalWidth) / 2;
        float textY = y - fontSize;

        // Draw "before" text
        cs.beginText();
        cs.setFont(fontRegular, fontSize);
        cs.newLineAtOffset(startX, textY);
        cs.showText(sanitizeText(before));
        cs.endText();

        // Draw bold part
        cs.beginText();
        cs.setFont(fontBold, fontSize);
        cs.newLineAtOffset(startX + beforeWidth, textY);
        cs.showText(sanitizeText(boldPart));
        cs.endText();

        // Draw "after" text
        cs.beginText();
        cs.setFont(fontRegular, fontSize);
        cs.newLineAtOffset(startX + beforeWidth + boldWidth, textY);
        cs.showText(sanitizeText(after));
        cs.endText();

        return y - fontSize;
    }

    /**
     * Splits address into 2 lines if it contains a comma or is too long.
     */
    private String[] splitAddress(String address) {
        if (address == null || address.isBlank()) {
            return new String[]{""};
        }
        // Split on comma if present
        if (address.contains(",")) {
            String[] parts = address.split(",", 2);
            return new String[]{parts[0].trim(), parts.length > 1 ? parts[1].trim() : ""};
        }
        // If too long, split at middle space
        if (address.length() > 35) {
            int mid = address.length() / 2;
            int spaceIndex = address.indexOf(' ', mid);
            if (spaceIndex == -1) {
                spaceIndex = address.lastIndexOf(' ', mid);
            }
            if (spaceIndex > 0) {
                return new String[]{address.substring(0, spaceIndex).trim(), address.substring(spaceIndex).trim()};
            }
        }
        return new String[]{address, ""};
    }

    /**
     * Gets weight display string in grams.
     */
    private String getWeightInGrams(String formatPot) {
        if (formatPot == null) {
            return "Poids net: 500g";
        }
        // Convert kg to grams if needed
        if (formatPot.toLowerCase().contains("1kg") || formatPot.equals("1kg")) {
            return "Poids net: 1000g";
        }
        if (formatPot.toLowerCase().contains("250")) {
            return "Poids net: 250g";
        }
        if (formatPot.toLowerCase().contains("500")) {
            return "Poids net: 500g";
        }
        return "Poids net: " + formatPot;
    }

    /**
     * Renders a label using default dimensions from configuration.
     */
    public void renderLabel(PDDocument document, PDPage page, EtiquetteData data, float x, float y) {
        renderLabel(document, page, data, x, y,
                etiquetteConfig.getLabelWidthMm(),
                etiquetteConfig.getLabelHeightMm());
    }

    /**
     * Draws a border rectangle at the specified position.
     */
    private void drawBorder(PDPageContentStream cs, float x, float y, float width, float height)
            throws IOException {
        cs.setLineWidth(BORDER_WIDTH_PT);
        cs.addRect(x, y, width, height);
        cs.stroke();
    }

    /**
     * Draws text centered within the specified width.
     *
     * @return the Y position after drawing (accounting for font descent)
     */
    private float drawCenteredText(PDPageContentStream cs, String text, PDFont font,
                                   float fontSize, float x, float y, float width) throws IOException {
        float textWidth = calculateTextWidth(text, font, fontSize);
        float centeredX = x + (width - textWidth) / 2;

        cs.beginText();
        cs.setFont(font, fontSize);
        cs.newLineAtOffset(centeredX, y - fontSize);
        cs.showText(sanitizeText(text));
        cs.endText();

        return y - fontSize;
    }

    /**
     * Draws text left-aligned.
     *
     * @return the Y position after drawing
     */
    private float drawLeftText(PDPageContentStream cs, String text, PDFont font,
                               float fontSize, float x, float y) throws IOException {
        cs.beginText();
        cs.setFont(font, fontSize);
        cs.newLineAtOffset(x, y - fontSize);
        cs.showText(sanitizeText(text));
        cs.endText();

        return y - fontSize;
    }

    /**
     * Draws text right-aligned within the specified width.
     */
    private void drawRightText(PDPageContentStream cs, String text, PDFont font,
                               float fontSize, float x, float y, float width) throws IOException {
        float textWidth = calculateTextWidth(text, font, fontSize);
        float rightX = x + width - textWidth;

        cs.beginText();
        cs.setFont(font, fontSize);
        cs.newLineAtOffset(rightX, y - fontSize);
        cs.showText(sanitizeText(text));
        cs.endText();
    }

    /**
     * Calculates the width of text in points.
     */
    private float calculateTextWidth(String text, PDFont font, float fontSize) throws IOException {
        return font.getStringWidth(sanitizeText(text)) / 1000 * fontSize;
    }

    /**
     * Truncates text to fit within the specified width, adding "..." if truncated.
     */
    private String truncateToFit(String text, PDFont font, float fontSize, float maxWidth) {
        try {
            if (calculateTextWidth(text, font, fontSize) <= maxWidth) {
                return text;
            }

            String ellipsis = "...";
            float ellipsisWidth = calculateTextWidth(ellipsis, font, fontSize);
            float availableWidth = maxWidth - ellipsisWidth;

            StringBuilder truncated = new StringBuilder();
            for (char c : text.toCharArray()) {
                String candidate = truncated.toString() + c;
                if (calculateTextWidth(candidate, font, fontSize) > availableWidth) {
                    break;
                }
                truncated.append(c);
            }

            return truncated.toString().trim() + ellipsis;
        } catch (IOException e) {
            // If calculation fails, return truncated by character count
            return text.length() > 40 ? text.substring(0, 37) + "..." : text;
        }
    }

    /**
     * Builds the product name line.
     * Returns just "Miel" without the type as per regulatory requirements.
     */
    private String buildProductName(String typeMiel) {
        return "Miel";
    }

    /**
     * Formats the price for display.
     */
    private String formatPrice(BigDecimal price) {
        if (price == null) {
            return "";
        }
        return String.format("%.2f EUR", price);
    }

    /**
     * Sanitizes text for PDF rendering, replacing unsupported characters.
     * Standard14 fonts support WinAnsiEncoding which includes most French accents.
     */
    private String sanitizeText(String text) {
        if (text == null) {
            return "";
        }
        // Replace characters not in WinAnsiEncoding
        return text
                .replace("\u0152", "OE")  // Œ
                .replace("\u0153", "oe")  // œ
                .replace("\u2019", "'")   // '
                .replace("\u2018", "'")   // '
                .replace("\u201C", "\"")  // "
                .replace("\u201D", "\"")  // "
                .replace("\u2013", "-")   // –
                .replace("\u2014", "-");  // —
    }

    /**
     * Generates a single label PDF for testing/preview purposes.
     *
     * @param data       the label data
     * @param outputPath path where the PDF will be saved
     */
    public void generateSingleLabelPdf(EtiquetteData data, Path outputPath) {
        log.info("Generating single label PDF to: {}", outputPath);

        try (PDDocument document = createDocument()) {
            PDPage page = createA4Page();
            document.addPage(page);

            // Render label at center of page
            float labelWidthPt = mmToPoints(etiquetteConfig.getLabelWidthMm());
            float labelHeightPt = mmToPoints(etiquetteConfig.getLabelHeightMm());
            float pageWidth = page.getMediaBox().getWidth();
            float pageHeight = page.getMediaBox().getHeight();

            float x = (pageWidth - labelWidthPt) / 2;
            float y = (pageHeight - labelHeightPt) / 2;

            renderLabel(document, page, data, x, y);

            document.save(outputPath.toFile());
            log.info("Single label PDF generated successfully: {}", outputPath);

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to generate single label PDF: " + e.getMessage(), e);
        }
    }

    // ==================== Multi-Label Sheet Generation ====================

    /**
     * Generates a single-page label sheet PDF with all label positions filled.
     * Grid layout and dimensions are determined by EtiquetteConfig.
     * Gaps between labels are calculated from remaining space on the A4 page.
     *
     * @param data the label data to repeat on all labels
     * @return byte array containing the PDF document
     */
    public byte[] generateEtiquetteSheet(EtiquetteData data) {
        if (data == null) {
            throw new IllegalArgumentException("Les données d'étiquette sont obligatoires");
        }

        int labelsPerPage = etiquetteConfig.getLabelsPerPage();
        log.info("Generating label sheet: {} labels ({}x{})",
                labelsPerPage, etiquetteConfig.getLabelsPerRow(), etiquetteConfig.getLabelsPerColumn());
        long startTime = System.currentTimeMillis();

        try (PDDocument document = createDocument();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            PDPage page = createA4Page();
            document.addPage(page);
            renderLabelsOnPage(document, page, data);

            document.save(baos);

            long duration = System.currentTimeMillis() - startTime;
            log.info("Label sheet generated: {} labels on 1 page in {}ms", labelsPerPage, duration);

            return baos.toByteArray();

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to generate label sheet: " + e.getMessage(), e);
        }
    }

    /**
     * Generates a single-page label sheet PDF using a specific preset.
     *
     * @param data   the label data to repeat on all labels
     * @param preset the label preset defining dimensions and grid
     * @return byte array containing the PDF document
     */
    public byte[] generateEtiquetteSheet(EtiquetteData data, LabelPreset preset) {
        if (data == null) {
            throw new IllegalArgumentException("Les données d'étiquette sont obligatoires");
        }
        if (preset == null) {
            return generateEtiquetteSheet(data);
        }

        int labelsPerPage = preset.getLabelsPerPage();
        log.info("Generating label sheet with preset '{}': {} labels ({}x{})",
                preset.getName(), labelsPerPage, preset.getLabelsPerRow(), preset.getLabelsPerColumn());
        long startTime = System.currentTimeMillis();

        try (PDDocument document = createDocument();
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

            PDPage page = createA4Page();
            document.addPage(page);
            renderLabelsOnPage(document, page, data, preset);

            document.save(baos);

            long duration = System.currentTimeMillis() - startTime;
            log.info("Label sheet generated: {} labels on 1 page in {}ms", labelsPerPage, duration);

            return baos.toByteArray();

        } catch (IOException e) {
            throw new PdfGenerationException("Failed to generate label sheet: " + e.getMessage(), e);
        }
    }

    /**
     * Renders all labels on a single page using a specific preset.
     */
    private void renderLabelsOnPage(PDDocument document, PDPage page, EtiquetteData data, LabelPreset preset) {
        float pageHeight = page.getMediaBox().getHeight();

        float marginTopPt = mmToPoints(preset.getMarginTopMm());
        float marginLeftPt = mmToPoints(preset.getMarginLeftMm());

        float labelWidthMm = preset.getLabelWidthMm();
        float labelHeightMm = preset.getLabelHeightMm();
        float labelWidthPt = mmToPoints(labelWidthMm);
        float labelHeightPt = mmToPoints(labelHeightMm);

        int cols = preset.getLabelsPerRow();
        int rows = preset.getLabelsPerColumn();

        float pageWidthPt = page.getMediaBox().getWidth();
        float usedWidth = marginLeftPt + (cols * labelWidthPt);
        float usedHeight = marginTopPt + (rows * labelHeightPt);
        float hGapPt = cols > 1 ? (pageWidthPt - usedWidth - marginLeftPt) / (cols - 1) : 0;
        float vGapPt = rows > 1 ? (pageHeight - usedHeight - marginTopPt) / (rows - 1) : 0;

        float startX = marginLeftPt;
        float startY = pageHeight - marginTopPt - labelHeightPt;

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                float x = startX + col * (labelWidthPt + hGapPt);
                float y = startY - row * (labelHeightPt + vGapPt);

                renderLabel(document, page, data, x, y, labelWidthMm, labelHeightMm);
            }
        }
    }

    /**
     * Renders all labels on a single page in a grid layout.
     * Gaps between labels are calculated from remaining space after placing
     * labels with configured dimensions and margins.
     *
     * @param document the PDF document
     * @param page     the page to render on
     * @param data     the label data
     */
    private void renderLabelsOnPage(PDDocument document, PDPage page, EtiquetteData data) {
        float pageHeight = page.getMediaBox().getHeight();

        float marginTopPt = mmToPoints(etiquetteConfig.getMarginTopMm());
        float marginLeftPt = mmToPoints(etiquetteConfig.getMarginLeftMm());

        float labelWidthMm = etiquetteConfig.getLabelWidthMm();
        float labelHeightMm = etiquetteConfig.getLabelHeightMm();
        float labelWidthPt = mmToPoints(labelWidthMm);
        float labelHeightPt = mmToPoints(labelHeightMm);

        int cols = etiquetteConfig.getLabelsPerRow();
        int rows = etiquetteConfig.getLabelsPerColumn();

        // Calculate gaps from remaining space
        float pageWidthPt = page.getMediaBox().getWidth();
        float usedWidth = marginLeftPt + (cols * labelWidthPt);
        float usedHeight = marginTopPt + (rows * labelHeightPt);
        float hGapPt = cols > 1 ? (pageWidthPt - usedWidth - marginLeftPt) / (cols - 1) : 0;
        float vGapPt = rows > 1 ? (pageHeight - usedHeight - marginTopPt) / (rows - 1) : 0;

        // Starting position (top-left of first label)
        float startX = marginLeftPt;
        float startY = pageHeight - marginTopPt - labelHeightPt;

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                float x = startX + col * (labelWidthPt + hGapPt);
                float y = startY - row * (labelHeightPt + vGapPt);

                renderLabel(document, page, data, x, y, labelWidthMm, labelHeightMm);
            }
        }
    }

    /**
     * Gets the number of labels per page from configuration.
     *
     * @return labels per page (rows x columns)
     */
    public int getLabelsPerPage() {
        return etiquetteConfig.getLabelsPerPage();
    }

}
